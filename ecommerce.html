<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>E-Commerce Platform - Architecture Documentation</title>
    
    <!-- Cytoscape.js and Dependencies -->
    <script src="https://unpkg.com/dagre@0.8.5/dist/dagre.min.js"></script>
    <script src="https://unpkg.com/cytoscape@3.26.0/dist/cytoscape.min.js"></script>
    <script src="https://unpkg.com/cytoscape-dagre@2.5.0/cytoscape-dagre.js"></script>
    
    <!-- Embedded Styles -->
    <style>
        /* Architecture Visualization Styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background-color: #f8f9fa;
    color: #333;
    overflow: hidden;
}

.container {
    display: flex;
    height: 100vh;
    width: 100vw;
}

/* Graph Area - 70% */
.graph-container {
    width: 70%;
    height: 100vh;
    position: relative;
    background: white;
    border-right: 2px solid #e9ecef;
}

#cy {
    width: 100%;
    height: 100%;
}

/* Controls */
.controls {
    position: absolute;
    top: 20px;
    left: 20px;
    z-index: 1000;
    display: flex;
    gap: 10px;
}

.btn {
    background: #007bff;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    transition: background-color 0.2s;
}

.btn:hover {
    background: #0056b3;
}

.btn-secondary {
    background: #6c757d;
}

.btn-secondary:hover {
    background: #545b62;
}

/* Sidebar - 30% */
.sidebar {
    width: 30%;
    height: 100vh;
    background: #f8f9fa;
    padding: 20px;
    overflow-y: auto;
    border-left: 1px solid #dee2e6;
}

.sidebar h2 {
    color: #495057;
    margin-bottom: 20px;
    font-size: 24px;
}

.sidebar h3 {
    color: #007bff;
    margin-bottom: 15px;
    font-size: 18px;
}

.component-details {
    background: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    margin-bottom: 20px;
}

.detail-section {
    margin-bottom: 20px;
}

.detail-label {
    font-weight: 600;
    color: #495057;
    margin-bottom: 8px;
    display: block;
}

.signature {
    background: #f8f9fa;
    padding: 12px;
    border-radius: 4px;
    border-left: 4px solid #007bff;
    font-family: 'Courier New', monospace;
    font-size: 13px;
    white-space: pre-wrap;
    overflow-x: auto;
}

.working-description {
    line-height: 1.6;
    color: #495057;
}

.imports-list {
    list-style: none;
    padding: 0;
}

.imports-list li {
    background: #e7f3ff;
    margin: 4px 0;
    padding: 6px 12px;
    border-radius: 4px;
    font-family: 'Courier New', monospace;
    font-size: 13px;
}

.breadcrumb {
    background: white;
    padding: 10px 20px;
    border-bottom: 1px solid #dee2e6;
    font-size: 14px;
    color: #6c757d;
}

.breadcrumb-item {
    display: inline;
}

.breadcrumb-item + .breadcrumb-item::before {
    content: " > ";
    margin: 0 8px;
    color: #adb5bd;
}

.breadcrumb-item.active {
    color: #007bff;
    font-weight: 500;
}

/* Loading and empty states */
.empty-state {
    text-align: center;
    color: #6c757d;
    padding: 40px 20px;
}

.loading {
    text-align: center;
    padding: 40px;
    color: #007bff;
}

/* Project header */
.project-header {
    background: linear-gradient(135deg, #007bff, #0056b3);
    color: white;
    padding: 20px;
    margin-bottom: 20px;
    border-radius: 8px;
}

.project-title {
    font-size: 24px;
    margin-bottom: 8px;
}

.project-description {
    opacity: 0.9;
    font-size: 14px;
}

/* Responsive */
@media (max-width: 768px) {
    .container {
        flex-direction: column;
    }
    
    .graph-container {
        width: 100%;
        height: 60vh;
    }
    
    .sidebar {
        width: 100%;
        height: 40vh;
    }
    
    .controls {
        position: relative;
        top: 10px;
        left: 10px;
        margin-bottom: 10px;
    }
}

/* Cytoscape node styling will be handled in JavaScript */

    </style>
</head>
<body>
    <div class="container">
        <!-- Graph Area (70%) -->
        <div class="graph-container">
            <!-- Controls -->
            <div class="controls">
                <button id="expand-all" class="btn">üìÇ Expand All</button>
                <button id="collapse-all" class="btn btn-secondary">üìÅ Collapse All</button>
                <button id="drill-down" class="btn btn-secondary">‚¨áÔ∏è Drill Down</button>
                <button id="drill-up" class="btn btn-secondary">‚¨ÜÔ∏è Drill Up</button>
                <button id="fit-view" class="btn btn-secondary">üéØ Fit View</button>
                <button id="reset-view" class="btn btn-secondary">üîÑ Reset</button>
            </div>
            
            <!-- Cytoscape Container -->
            <div id="cy"></div>
        </div>
        
        <!-- Sidebar (30%) -->
        <div class="sidebar">
            <!-- Project Information -->
            <div id="project-info">
                <!-- Will be populated by JavaScript -->
            </div>
            
            <!-- Navigation Breadcrumb -->
            <div class="breadcrumb">
                <span class="breadcrumb-item active">Root</span>
            </div>
            
            <!-- Component Details -->
            <div id="component-details">
                <div class="empty-state">
                    <h3>Component Explorer</h3>
                    <p>Hover over a component to see its details, or click to explore its structure.</p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Embedded JavaScript -->
    <script>
        // Architecture Visualization with Cytoscape.js

// Register Dagre extension
if (typeof cytoscape !== 'undefined' && typeof cytoscapeDagre !== 'undefined') {
    cytoscape.use(cytoscapeDagre);
} else if (typeof window !== 'undefined') {
    // Wait for libraries to load
    document.addEventListener('DOMContentLoaded', function() {
        if (typeof cytoscape !== 'undefined' && typeof cytoscapeDagre !== 'undefined') {
            cytoscape.use(cytoscapeDagre);
        }
    });
}

class ArchitectureViewer {
    constructor(containerId, data) {
        this.container = document.getElementById(containerId);
        this.architectureData = data;
        this.cy = null;
        this.state = {
            hoveredNode: null,
            selectedNode: null,
            visibleNodes: new Set(),
            navigationPath: ['root'],
            currentLevel: 0,
            maxLevel: 0
        };
        
        this.init();
    }
    
    init() {
        this.setupCytoscape();
        this.setupEventHandlers();
        this.calculateMaxLevel(); // Calculate the maximum hierarchy depth
        this.initialLayout();
        this.updateProjectHeader();
    }
    
    setupCytoscape() {
        // Process data for Cytoscape
        const elements = this.processArchitectureData();
        
        this.cy = cytoscape({
            container: this.container,
            elements: elements,
            style: this.getStylesheet(),
            layout: { name: 'grid' }, // Will be replaced with proper layout
            
            // Simple, clean settings - no fancy stuff
            minZoom: 0.1,
            maxZoom: 3,
            zoomingEnabled: true,
            panningEnabled: true,
            boxSelectionEnabled: false,
            selectionType: 'single',
            autoungrabify: false,
            autounselectify: false
        });
    }
    
    processArchitectureData() {
        const nodes = this.architectureData.nodes.map(node => ({
            group: 'nodes',
            data: {
                id: node.id,
                label: node.data.label,
                type: node.data.type || 'default',
                details: this.architectureData.details[node.id] || {}
            },
            classes: node.data.type || 'default'
        }));
        
        const edges = this.architectureData.edges.map(edge => ({
            group: 'edges',
            data: {
                id: `${edge.source}-${edge.target}`,
                source: edge.source,
                target: edge.target
            }
        }));
        
        return [...nodes, ...edges];
    }
    
    getStylesheet() {
        return [
            // Node styles
            {
                selector: 'node',
                style: {
                    'background-color': '#66BB6A',
                    'label': 'data(label)',
                    'text-valign': 'center',
                    'text-halign': 'center',
                    'color': '#fff',
                    'font-size': '12px',
                    'font-weight': 'bold',
                    'width': '80px',
                    'height': '80px',
                    'border-width': '2px',
                    'border-color': '#4CAF50',
                    'text-wrap': 'wrap',
                    'text-max-width': '70px',
                    'overlay-opacity': 0,
                    'transition-property': 'background-color, border-color, width, height',
                    'transition-duration': '0.3s'
                }
            },
            
            // Type-specific node styles
            {
                selector: 'node.application',
                style: {
                    'background-color': '#2196F3',
                    'border-color': '#1976D2',
                    'width': '100px',
                    'height': '100px',
                    'font-size': '14px'
                }
            },
            
            {
                selector: 'node.backend',
                style: {
                    'background-color': '#FF5722',
                    'border-color': '#D84315',
                    'shape': 'rectangle'
                }
            },
            
            {
                selector: 'node.component',
                style: {
                    'background-color': '#9C27B0',
                    'border-color': '#7B1FA2'
                }
            },
            
            {
                selector: 'node.entry',
                style: {
                    'background-color': '#FF9800',
                    'border-color': '#F57C00',
                    'shape': 'diamond'
                }
            },
            
            {
                selector: 'node.frontend',
                style: {
                    'background-color': '#4CAF50',
                    'border-color': '#388E3C',
                    'shape': 'rectangle'
                }
            },
            
            {
                selector: 'node.database',
                style: {
                    'background-color': '#795548',
                    'border-color': '#5D4037',
                    'shape': 'barrel'
                }
            },
            
            {
                selector: 'node.cache',
                style: {
                    'background-color': '#607D8B',
                    'border-color': '#455A64',
                    'shape': 'hexagon'
                }
            },
            
            // Hover effects
            {
                selector: 'node:active',
                style: {
                    'overlay-opacity': 0.2,
                    'overlay-color': '#000'
                }
            },
            
            // Selected state
            {
                selector: 'node:selected',
                style: {
                    'border-width': '4px',
                    'border-color': '#333'
                }
            },
            
            // Edge styles
            {
                selector: 'edge',
                style: {
                    'curve-style': 'bezier',
                    'target-arrow-shape': 'triangle',
                    'line-color': '#95A5A6',
                    'target-arrow-color': '#95A5A6',
                    'width': '3px',
                    'arrow-scale': 1.2,
                    'transition-property': 'line-color, target-arrow-color, width',
                    'transition-duration': '0.3s'
                }
            },
            
            // Highlighted edges
            {
                selector: 'edge.highlighted',
                style: {
                    'line-color': '#E74C3C',
                    'target-arrow-color': '#E74C3C',
                    'width': '4px'
                }
            },
            
            // Hidden elements
            {
                selector: '.hidden',
                style: {
                    'display': 'none'
                }
            }
        ];
    }
    
    setupEventHandlers() {
        // Node hover
        this.cy.on('mouseover', 'node', (event) => {
            const node = event.target;
            this.handleNodeHover(node);
        });
        
        this.cy.on('mouseout', 'node', (event) => {
            this.clearHighlights();
        });
        
        // Node click 
        this.cy.on('tap', 'node', (event) => {
            const node = event.target;
            this.handleNodeClick(node);
        });
        
        // Background click
        this.cy.on('tap', (event) => {
            if (event.target === this.cy) {
                this.clearSelection();
            }
        });
    }
    
    handleNodeHover(node) {
        this.state.hoveredNode = node;
        
        // Highlight connected elements
        const connectedEdges = node.connectedEdges();
        connectedEdges.addClass('highlighted');
        
        // Update sidebar
        this.updateSidebar(node);
    }
    
    handleNodeClick(node) {
        this.state.selectedNode = node;
        
        // Check if node has children in hierarchy
        const nodeId = node.id();
        const children = this.architectureData.hierarchy[nodeId];
        
        if (children && children.length > 0) {
            this.toggleNodeChildren(node, children);
        }
        
        // Update sidebar with permanent selection
        this.updateSidebar(node);
    }
    
    toggleNodeChildren(parentNode, childrenIds) {
        const parentId = parentNode.id();
        
        // Check if children are currently visible
        const firstChild = this.cy.getElementById(childrenIds[0]);
        const areChildrenVisible = firstChild.length > 0 && !firstChild.hasClass('hidden');
        
        if (areChildrenVisible) {
            // Hide children
            this.hideNodeChildren(childrenIds);
        } else {
            // Show children
            this.showNodeChildren(childrenIds);
        }
        
        // Re-layout after visibility changes
        this.applyLayout();
    }
    
    showNodeChildren(childrenIds) {
        childrenIds.forEach(childId => {
            const childNode = this.cy.getElementById(childId);
            if (childNode.length > 0) {
                childNode.removeClass('hidden');
                this.state.visibleNodes.add(childId);
            }
        });
    }
    
    hideNodeChildren(childrenIds) {
        // Recursively hide children and their descendants
        const toHide = new Set();
        
        const addDescendants = (nodeId) => {
            toHide.add(nodeId);
            const children = this.architectureData.hierarchy[nodeId] || [];
            children.forEach(addDescendants);
        };
        
        childrenIds.forEach(addDescendants);
        
        toHide.forEach(nodeId => {
            const node = this.cy.getElementById(nodeId);
            if (node.length > 0) {
                node.addClass('hidden');
                this.state.visibleNodes.delete(nodeId);
            }
        });
    }
    
    clearHighlights() {
        this.cy.edges().removeClass('highlighted');
        if (!this.state.selectedNode) {
            this.updateSidebar(null);
        }
    }
    
    clearSelection() {
        this.state.selectedNode = null;
        this.updateSidebar(null);
    }
    
    updateSidebar(node) {
        const sidebar = document.getElementById('component-details');
        
        if (!node) {
            sidebar.innerHTML = `
                <div class="empty-state">
                    <h3>Component Explorer</h3>
                    <p>Hover over a component to see its details, or click to explore its structure.</p>
                </div>
            `;
            return;
        }
        
        const nodeData = node.data();
        const details = nodeData.details || {};
        
        sidebar.innerHTML = `
            <h3>${nodeData.label}</h3>
            
            <div class="detail-section">
                <span class="detail-label">Summary:</span>
                <p class="working-description">${details.summary || 'No description available.'}</p>
            </div>
            
            ${details.signature ? `
                <div class="detail-section">
                    <span class="detail-label">Signature:</span>
                    <div class="signature">${details.signature}</div>
                </div>
            ` : ''}
            
            ${details.working ? `
                <div class="detail-section">
                    <span class="detail-label">How it works:</span>
                    <p class="working-description">${details.working}</p>
                </div>
            ` : ''}
            
            ${details.imports && details.imports.length > 0 ? `
                <div class="detail-section">
                    <span class="detail-label">Dependencies:</span>
                    <ul class="imports-list">
                        ${details.imports.map(imp => `<li>${imp}</li>`).join('')}
                    </ul>
                </div>
            ` : ''}
        `;
    }
    
    updateProjectHeader() {
        const header = document.getElementById('project-info');
        const metadata = this.architectureData.metadata || {};
        
        header.innerHTML = `
            <div class="project-header">
                <h1 class="project-title">${metadata.projectName || 'Architecture Documentation'}</h1>
                <p class="project-description">${metadata.description || 'Interactive component visualization'}</p>
            </div>
        `;
    }
    
    initialLayout() {
        // Hide all children initially, show only top-level nodes
        const topLevelNodes = this.getTopLevelNodes();
        
        this.cy.nodes().forEach(node => {
            const nodeId = node.id();
            if (topLevelNodes.includes(nodeId)) {
                this.state.visibleNodes.add(nodeId);
            } else {
                node.addClass('hidden');
            }
        });
        
        this.applyLayout();
    }
    
    getTopLevelNodes() {
        const allNodes = this.architectureData.nodes.map(n => n.id);
        const childNodes = new Set();
        
        // Find all nodes that are children of others
        Object.values(this.architectureData.hierarchy).forEach(children => {
            children.forEach(child => childNodes.add(child));
        });
        
        // Top-level nodes are those that are not children of any other node
        return allNodes.filter(nodeId => !childNodes.has(nodeId));
    }
    
    applyLayout() {
        const visibleElements = this.cy.elements().filter(ele => !ele.hasClass('hidden'));
        
        const layout = visibleElements.layout({
            name: 'dagre',
            rankDir: 'TB',
            nodeSep: 50,
            rankSep: 100,
            marginX: 50,
            marginY: 50,
            animate: true,
            animationDuration: 500,
            animationEasing: 'ease-out',
            fit: true,
            padding: 50
        });
        
        layout.run();
    }
    
    // Control methods
    expandAll() {
        // Show all nodes
        this.cy.nodes().removeClass('hidden');
        
        // Update visible nodes state
        this.state.visibleNodes.clear();
        this.architectureData.nodes.forEach(node => {
            this.state.visibleNodes.add(node.id);
        });
        
        // Apply layout with a slight delay to ensure nodes are visible
        setTimeout(() => {
            this.applyLayout();
        }, 100);
    }
    
    collapseAll() {
        this.initialLayout();
    }
    
    fitView() {
        const visibleElements = this.cy.elements().filter(ele => !ele.hasClass('hidden'));
        this.cy.fit(visibleElements, 50);
    }
    
    resetView() {
        this.state.currentLevel = 0; // Reset drill level
        this.cy.reset();
        this.collapseAll();
    }

    // Level-based drill methods
    calculateMaxLevel() {
        const getNodeLevel = (nodeId, level = 0) => {
            const children = this.architectureData.hierarchy[nodeId];
            if (!children || children.length === 0) {
                return level;
            }
            
            let maxChildLevel = level;
            children.forEach(childId => {
                const childLevel = getNodeLevel(childId, level + 1);
                maxChildLevel = Math.max(maxChildLevel, childLevel);
            });
            
            return maxChildLevel;
        };

        // Start from top-level nodes
        const topLevelNodes = this.getTopLevelNodes();
        let maxLevel = 0;
        
        topLevelNodes.forEach(nodeId => {
            const nodeLevel = getNodeLevel(nodeId, 0);
            maxLevel = Math.max(maxLevel, nodeLevel);
        });
        
        this.state.maxLevel = maxLevel;
        return maxLevel;
    }

    drillDown() {
        if (this.state.currentLevel >= this.state.maxLevel) {
            return;
        }

        this.state.currentLevel++;
        this.showNodesUpToLevel(this.state.currentLevel);
    }

    drillUp() {
        if (this.state.currentLevel <= 0) {
            return;
        }

        this.state.currentLevel--;
        this.showNodesUpToLevel(this.state.currentLevel);
    }

    showNodesUpToLevel(targetLevel) {
        // First hide all nodes
        this.cy.nodes().addClass('hidden');
        this.state.visibleNodes.clear();

        const showNodeAndAncestors = (nodeId, currentLevel = 0) => {
            if (currentLevel <= targetLevel) {
                // Show this node
                const node = this.cy.getElementById(nodeId);
                if (node.length > 0) {
                    node.removeClass('hidden');
                    this.state.visibleNodes.add(nodeId);
                }

                // Show children if we haven't reached target level
                if (currentLevel < targetLevel) {
                    const children = this.architectureData.hierarchy[nodeId];
                    if (children) {
                        children.forEach(childId => {
                            showNodeAndAncestors(childId, currentLevel + 1);
                        });
                    }
                }
            }
        };

        // Start from top-level nodes
        const topLevelNodes = this.getTopLevelNodes();
        topLevelNodes.forEach(nodeId => {
            showNodeAndAncestors(nodeId, 0);
        });

        // Apply layout to visible nodes
        this.applyLayout();
    }
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    // Architecture data will be injected here by the generator
    const architectureData = {
  "metadata": {
    "projectName": "E-Commerce Platform",
    "description": "Microservices-based e-commerce platform with React frontend",
    "version": "2.1.0",
    "generated": "2025-08-18"
  },
  "nodes": [
    {
      "id": "platform",
      "data": {
        "label": "E-Commerce Platform",
        "type": "application"
      }
    },
    {
      "id": "frontend",
      "data": {
        "label": "React Frontend",
        "type": "frontend"
      }
    },
    {
      "id": "api-gateway",
      "data": {
        "label": "API Gateway",
        "type": "backend"
      }
    },
    {
      "id": "user-service",
      "data": {
        "label": "User Service",
        "type": "backend"
      }
    },
    {
      "id": "product-service",
      "data": {
        "label": "Product Service",
        "type": "backend"
      }
    },
    {
      "id": "order-service",
      "data": {
        "label": "Order Service",
        "type": "backend"
      }
    },
    {
      "id": "payment-service",
      "data": {
        "label": "Payment Service",
        "type": "backend"
      }
    },
    {
      "id": "notification-service",
      "data": {
        "label": "Notification Service",
        "type": "backend"
      }
    },
    {
      "id": "user-db",
      "data": {
        "label": "User Database",
        "type": "database"
      }
    },
    {
      "id": "product-db",
      "data": {
        "label": "Product Database",
        "type": "database"
      }
    },
    {
      "id": "order-db",
      "data": {
        "label": "Order Database",
        "type": "database"
      }
    },
    {
      "id": "redis-cache",
      "data": {
        "label": "Redis Cache",
        "type": "cache"
      }
    }
  ],
  "details": {
    "platform": {
      "summary": "Complete e-commerce platform handling user management, product catalog, orders, and payments",
      "signature": "microservices architecture",
      "working": "The platform consists of multiple microservices communicating through an API gateway. Each service handles a specific domain and has its own database for data isolation.",
      "imports": []
    },
    "frontend": {
      "summary": "React-based single page application providing user interface for the e-commerce platform",
      "signature": "React 18 + Redux Toolkit + React Router",
      "working": "Built with React 18 and Redux for state management. Communicates with backend services through the API gateway. Responsive design supporting both desktop and mobile users.",
      "imports": [
        "api-gateway"
      ]
    },
    "api-gateway": {
      "summary": "Central entry point that routes requests to appropriate microservices and handles cross-cutting concerns",
      "signature": "Express.js + JWT authentication + Rate limiting",
      "working": "Routes incoming requests to appropriate microservices based on URL patterns. Handles authentication using JWT tokens, rate limiting, request logging, and response caching. Implements circuit breaker pattern for fault tolerance.",
      "imports": [
        "user-service",
        "product-service",
        "order-service",
        "payment-service",
        "notification-service"
      ]
    },
    "user-service": {
      "summary": "Manages user accounts, authentication, profiles, and authorization",
      "signature": "Node.js + Express + JWT + bcrypt",
      "working": "Handles user registration, login, profile management, and password reset functionality. Uses bcrypt for password hashing and JWT for session management. Implements role-based access control.",
      "imports": [
        "user-db",
        "redis-cache"
      ]
    },
    "product-service": {
      "summary": "Manages product catalog, inventory, categories, and search functionality",
      "signature": "Node.js + Express + Elasticsearch",
      "working": "Provides CRUD operations for products, categories, and inventory management. Implements full-text search using Elasticsearch. Handles product images and metadata.",
      "imports": [
        "product-db",
        "redis-cache"
      ]
    },
    "order-service": {
      "summary": "Handles order processing, shopping cart, and order history",
      "signature": "Node.js + Express + Saga pattern",
      "working": "Manages the complete order lifecycle from cart creation to fulfillment. Implements saga pattern for distributed transactions. Coordinates with payment and notification services.",
      "imports": [
        "order-db",
        "payment-service",
        "notification-service"
      ]
    },
    "payment-service": {
      "summary": "Processes payments, refunds, and integrates with external payment providers",
      "signature": "Node.js + Stripe API + PCI compliance",
      "working": "Handles payment processing through multiple providers (Stripe, PayPal). Implements secure payment flows with PCI compliance. Manages payment history and refund processes.",
      "imports": [
        "notification-service"
      ]
    },
    "notification-service": {
      "summary": "Sends emails, SMS, and push notifications for various platform events",
      "signature": "Node.js + SendGrid + Firebase",
      "working": "Handles all outbound communications including order confirmations, password resets, promotional emails, and push notifications. Uses templates for consistent messaging.",
      "imports": []
    },
    "user-db": {
      "summary": "PostgreSQL database storing user accounts, profiles, and authentication data",
      "signature": "PostgreSQL 14 + connection pooling",
      "working": "Stores user information with proper indexing for performance. Implements data encryption for sensitive information. Uses connection pooling for efficient resource usage.",
      "imports": []
    },
    "product-db": {
      "summary": "MongoDB database storing product catalog, categories, and inventory data",
      "signature": "MongoDB 6.0 + GridFS for images",
      "working": "Document-based storage optimized for product catalog with flexible schema. Uses GridFS for storing product images. Implements proper indexing for search performance.",
      "imports": []
    },
    "order-db": {
      "summary": "PostgreSQL database storing order data, transactions, and order history",
      "signature": "PostgreSQL 14 + partitioning",
      "working": "Stores order information with ACID compliance for data integrity. Uses table partitioning for performance at scale. Implements audit logging for order changes.",
      "imports": []
    },
    "redis-cache": {
      "summary": "In-memory cache for session data, frequently accessed data, and rate limiting",
      "signature": "Redis 7.0 + clustering",
      "working": "Provides high-performance caching for user sessions, product data, and API rate limiting. Implements cache invalidation strategies and data expiration policies.",
      "imports": []
    }
  },
  "hierarchy": {
    "platform": [
      "frontend",
      "api-gateway"
    ],
    "api-gateway": [
      "user-service",
      "product-service",
      "order-service",
      "payment-service",
      "notification-service"
    ],
    "user-service": [
      "user-db",
      "redis-cache"
    ],
    "product-service": [
      "product-db",
      "redis-cache"
    ],
    "order-service": [
      "order-db"
    ]
  },
  "edges": [
    {
      "source": "platform",
      "target": "frontend"
    },
    {
      "source": "platform",
      "target": "api-gateway"
    },
    {
      "source": "frontend",
      "target": "api-gateway"
    },
    {
      "source": "api-gateway",
      "target": "user-service"
    },
    {
      "source": "api-gateway",
      "target": "product-service"
    },
    {
      "source": "api-gateway",
      "target": "order-service"
    },
    {
      "source": "api-gateway",
      "target": "payment-service"
    },
    {
      "source": "api-gateway",
      "target": "notification-service"
    },
    {
      "source": "user-service",
      "target": "user-db"
    },
    {
      "source": "user-service",
      "target": "redis-cache"
    },
    {
      "source": "product-service",
      "target": "product-db"
    },
    {
      "source": "product-service",
      "target": "redis-cache"
    },
    {
      "source": "order-service",
      "target": "order-db"
    },
    {
      "source": "order-service",
      "target": "payment-service"
    },
    {
      "source": "order-service",
      "target": "notification-service"
    },
    {
      "source": "payment-service",
      "target": "notification-service"
    }
  ]
};
    
    // Create the viewer
    window.architectureViewer = new ArchitectureViewer('cy', architectureData);
    
    // Setup control buttons with error handling
    const expandBtn = document.getElementById('expand-all');
    if (expandBtn) {
        expandBtn.addEventListener('click', (e) => {
            e.preventDefault();
            window.architectureViewer.expandAll();
        });
    }
    
    const collapseBtn = document.getElementById('collapse-all');
    if (collapseBtn) {
        collapseBtn.addEventListener('click', (e) => {
            e.preventDefault();
            window.architectureViewer.collapseAll();
        });
    }
    
    const fitBtn = document.getElementById('fit-view');
    if (fitBtn) {
        fitBtn.addEventListener('click', (e) => {
            e.preventDefault();
            window.architectureViewer.fitView();
        });
    }
    
    const resetBtn = document.getElementById('reset-view');
    if (resetBtn) {
        resetBtn.addEventListener('click', (e) => {
            e.preventDefault();
            window.architectureViewer.resetView();
        });
    }

    // Drill down/up buttons
    const drillDownBtn = document.getElementById('drill-down');
    if (drillDownBtn) {
        drillDownBtn.addEventListener('click', (e) => {
            e.preventDefault();
            window.architectureViewer.drillDown();
        });
    }

    const drillUpBtn = document.getElementById('drill-up');
    if (drillUpBtn) {
        drillUpBtn.addEventListener('click', (e) => {
            e.preventDefault();
            window.architectureViewer.drillUp();
        });
    }
});

    </script>
</body>
</html>
